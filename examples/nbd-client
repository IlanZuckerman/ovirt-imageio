#!/usr/bin/python
# ovirt-imageio
# Copyright (C) 2018 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

"""
nbd client example

Show how to use nbd module to upload images to nbd server.

Usage
-----

Start qemu-nbd with a destination image in any format supported by
qemu-img.  To access raw images, you can also use nbdkit or nbd-server.

    $ qemu-nbd \
        --socket /tmp/nbd.sock \
        --format qcow2 \
        --export-name=export \
        --persistent \
        --cache=none \
        --aio=native \
        --discard=unmap \
        --detect-zeroes=unmap \
        dest.qcow2

Upload source image to destination image via qemu-nbd:

    $ ./nbd-client -e export upload src.raw /tmp/nbb.sock

"""

import argparse
import io
import json
import os
import subprocess
import sys

from ovirt_imageio_common import nbd
from ovirt_imageio_common import ui


def upload(args):
    size = os.path.getsize(args.filename)
    with io.open(args.filename, "rb") as src, \
            nbd.Client(args.socket, args.export) as dst, \
            ui.ProgressBar(size) as pb:
        if dst.export_size < size:
            raise Exception("Destination size {} is smaller than source file "
                            "size {}".format(dst.export_size, todo))
        for zero, start, length in _map(args.filename):
            if zero:
                _zero_range(dst, start, length, pb)
            else:
                _copy_range(dst, src, start, length, pb, args.block_size)
        dst.flush()


def _map(path):
    out = subprocess.check_output([
        "qemu-img",
        "map",
        "--format", "raw",
        "--output", "json",
        path
    ])
    chunks = json.loads(out.decode("utf-8"))
    for c in chunks:
        yield c["zero"], c["start"], c["length"]


def _zero_range(dst, start, length, pb):
    while length:
        step = min(dst.maximum_block_size, length)
        dst.zero(start, step)
        start += step
        length -= step
        pb.update(step)


def _copy_range(dst, src, start, length, pb, block_size):
    max_step = min(dst.maximum_block_size, block_size)
    src.seek(start)
    while length:
        chunk = src.read(min(length, max_step))
        if not chunk:
            raise Exception("Unexpected end of file, expecting {} bytes"
                            .format(length))
        dst.write(start, chunk)
        n = len(chunk)
        start += n
        length -= n
        pb.update(n)


def kib(s):
    return int(s) * 1024


parser = argparse.ArgumentParser(description="nbd example")
parser.add_argument(
    "-e", "--export",
    default="", help="export name")
parser.add_argument(
    "-b", "--block-size",
    default=8 * 1024**2,
    type=kib,
    help="block size in KiB")

commands = parser.add_subparsers(title="commands")

upload_parser = commands.add_parser(
    "upload",
    help="upload image data to nbd server")
upload_parser.set_defaults(command=upload)
upload_parser.add_argument(
    "filename",
    help="filename to copy")
upload_parser.add_argument(
    "socket",
    help="nbd socket")

args = parser.parse_args()
args.command(args)
