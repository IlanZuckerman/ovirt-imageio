#!/usr/bin/python3
# ovirt-imageio
# Copyright (C) 2018 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

"""
nbd client example

Show how to use nbd module to upload and download images to/from nbd server.

Usage
-----

Start qemu-nbd with a destination image in any format supported by
qemu-img.  To access raw images, you can also use nbdkit or nbd-server.

    $ qemu-nbd \
        --socket /tmp/nbd.sock \
        --format qcow2 \
        --export-name=export \
        --persistent \
        --cache=none \
        --aio=native \
        --discard=unmap \
        --detect-zeroes=unmap \
        image.qcow2

Upload raw file to qcow2 image via qemu-nbd:

    $ ./nbd-client -e export upload file.raw nbd:unix:/tmp/nbb.sock

Download qcow2 image to raw file via qemu-nbd:

    $ ./nbd-client -e export download nbd:unix:/tmp/nbb.sock file.raw
"""

import argparse
import errno
import io
import json
import logging
import os
import subprocess
import sys

from six.moves.urllib.parse import urlparse

from ovirt_imageio_common import nbd
from ovirt_imageio_common import ui


def upload(args):
    size = os.path.getsize(args.filename)
    with io.open(args.filename, "rb") as src, \
            nbd.open(urlparse(args.nbd_url)) as dst:
        if dst.export_size < size:
            raise Exception("Destination size {} is smaller than source file "
                            "size {}".format(dst.export_size, size))
        pb = None
        if not args.silent:
            pb = ui.ProgressBar(size)

        for zero, start, length in _map(args.filename):
            if zero:
                _zero_range(dst, start, length, pb)
            else:
                _copy_range(dst, src, start, length, pb, args.block_size)

        dst.flush()

        if pb:
            pb.close()


def download(args):
    with nbd.open(urlparse(args.nbd_url)) as src, \
            io.open(args.filename, "wb") as dst:

        pb = None
        if not args.silent:
            pb = ui.ProgressBar(src.export_size)

        # NBD has a limit of 32 MiB for request length. We let the user
        # choose a lower step size for tuning the copy.
        max_step = min(src.maximum_block_size, args.block_size)

        buf = bytearray(max_step)

        # Start by truncating the file to the right size. Ignoring EINVAL
        # allows coping to /dev/null for testing read throughput.
        logging.debug("truncate length=%s", src.export_size)
        try:
            dst.truncate(src.export_size)
        except EnvironmentError as e:
            if e.errno != errno.EINVAL:
                raise

        # Iterate over all extents in the image.
        offset = 0
        for ext in _extents(src):
            if ext.zero:
                # Seek over zeroes, creating a hole.
                logging.debug("zero offset=%s length=%s", offset, ext.length)
                offset += ext.length
                dst.seek(offset)
                if pb:
                    pb.update(ext.length)
            else:
                # Copy data from source for data extents. Note that extents
                # length is 64 bits, but NBD supports up to 32 MiB per
                # request, so we must split the work to multiple calls.
                todo = ext.length
                while todo:
                    step = min(todo, max_step)
                    view = memoryview(buf)[:step]

                    src.readinto(offset, view)
                    logging.debug("write offset=%s length=%s", offset, step)
                    dst.write(view)

                    todo -= step
                    offset += step
                    if pb:
                        pb.update(step)

        # Finally wait until the data reasch the underlying storage.
        # Ignoring EINVAL so we can copy to /dev/null for testing read
        # throughput.
        logging.debug("flush")
        try:
            os.fsync(dst.fileno())
        except OSError as e:
            if e.errno != errno.EINVAL:
                raise

        if pb:
            pb.close()


def _extents(src):
    # Keep the current extents, until we find a new extents with different
    # zero value.
    cur = None

    # NBD limit extents request to 4 GiB - 1. We use smaller step to limit the
    # number of extents kept in memory when working on very fragmented images.
    max_len=1024**3

    # Iterate over entire image length.
    offset = 0
    while offset < src.export_size:
        # Get the extents for the current range.
        length = min(src.export_size - offset, max_len)
        res = src.extents(offset, length)

        # Iterate on extents, merging extents with same zero value into
        # current one.
        for ext in res["base:allocation"]:
            offset += ext.length
            if cur is None:
                cur = ext
            elif cur.zero == ext.zero:
                cur.length += ext.length
            else:
                yield cur
                cur = ext

    # No more extents. Time to yield the current extent. NBD spec and client
    # ensure that we have at least one extent per image.
    yield cur


def _map(path):
    logging.debug("getting extents")
    out = subprocess.check_output([
        "qemu-img",
        "map",
        "--format", "raw",
        "--output", "json",
        path
    ])
    chunks = json.loads(out.decode("utf-8"))
    for c in chunks:
        yield c["zero"], c["start"], c["length"]


def _zero_range(dst, start, length, pb):
    while length:
        step = min(dst.maximum_block_size, length)
        dst.zero(start, step)
        start += step
        length -= step
        if pb:
            pb.update(step)


def _copy_range(dst, src, start, length, pb, block_size):
    max_step = min(dst.maximum_block_size, block_size)
    src.seek(start)
    while length:
        chunk = src.read(min(length, max_step))
        if not chunk:
            raise Exception("Unexpected end of file, expecting {} bytes"
                            .format(length))
        n = len(chunk)
        logging.debug("read offset=%s, length=%s", start, n)
        dst.write(start, chunk)
        start += n
        length -= n
        if pb:
            pb.update(n)


def kib(s):
    return int(s) * 1024


parser = argparse.ArgumentParser(description="nbd example")
parser.add_argument(
    "-b", "--block-size",
    # 4M is significantly faster than 8M on download, and about the same on
    # upload.
    default=4 * 1024**2,
    type=kib,
    help="block size in KiB")
parser.add_argument(
    "-v", "--verbose",
    action="store_true",
    help="Be more verbose")
parser.add_argument(
    "-s", "--silent",
    action="store_true",
    help="Disable progress")

commands = parser.add_subparsers(title="commands")

upload_parser = commands.add_parser(
    "upload",
    help="upload image data to nbd server")
upload_parser.set_defaults(command=upload)
upload_parser.add_argument(
    "filename",
    help="filename to copy")
upload_parser.add_argument(
    "nbd_url",
    help="NBD URL (nbd:unix:/sock or nbd:localhost:10809)")

download_parser = commands.add_parser(
    "download",
    help="download image data from nbd server")
download_parser.set_defaults(command=download)
download_parser.add_argument(
    "nbd_url",
    help="NBD URL (nbd:unix:/sock or nbd:localhost:10809)")
download_parser.add_argument(
    "filename",
    help="filename to write")

args = parser.parse_args()

logging.basicConfig(
    level=logging.DEBUG if args.verbose else logging.WARNING,
    format="nbd-client: %(levelname)-7s %(message)s")

args.command(args)
